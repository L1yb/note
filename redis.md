# Redis

# 一、数据结构与对象

## 1、 简单动态字符串

redis使用的字符串不同于c语言字符串（使用空字符作为结尾），而是自己构建一个抽象数据类型 **SDS（Simple Dynamic String）简单动态字符串**为**默认字符串**。

例如

~~~c
SET msg "hello world"
RPUSH fruit "apple" "banana" "orange"
~~~

- 键值对的key 是一个字符串对象，底层是一个保存着字符串“msg”的SDS
- 键值对的value也是字符串对象，底层是一个保存着字符串“hello world” 的SDS

- key fruit的 value是一个list 对象，包含了三个SDS，分别保存

> 除此之外，SDS还被使用为缓冲器buffer，后面学到AOF持久化和客户端状态会讲到



## 2、SDS的定义

```c
struct sdshdr
{
    //记录buf字节数组已使用的字节数量
    //等于 SDS保存的字节长度
    int len;
    //记录buf数组中未使用的字节数量
    int free;
    //字节数组，用于保存字符串
    char buf[];
}

```

例如 buf保存“redis” ，数组的前五个字节分别是'r' 'e' 'd' 'i' 's',最后一个字节保存了空字符‘\0’

但是len的属性是5

**换句话说，SDS中buf数组还是c字符串，但是SDS是个结构体，len赋值时会忽略空字符的计算**

至于其他函数操作有待观察

## 3、SDS和C字符串的区别

关键词： "复杂度"”溢出“”重分配“

### 获取字符串长度复杂度为常数

对于c字符串，获取长度需要遍历，当遍历到空字符时，返回长度

而SDS只需要调用STRLEN即可获取长度

### 杜绝缓冲区溢出

例如， 在c语言中， 拼接两个字符串strcat(s1, ”redis“)，加入s1,s2是相邻存储的，那么s2会被覆盖，也就是”**s1的内容溢出到s2的位置**“

但是SDS则不会出现，sdscat(s,"redis"),API会首先检查s的内存空间是否足够，不够的话会自动拓展内存，具体方法后续讲到

str1 = "hello"   五个字符

str2 = "redis" 五个字符

他们相加之后len = 11；因为str还有一个空字符，拼接是空字符变成空格，并且free被置为11，意味着又额外分配了11个字符空间

### 减少修改字符串时带来的内存重分配次数

如果时c字符串

- 字符串增长时需要扩展内存
- 字符串缩短时需要释放不使用内存

如果频繁的修改数据长度，那么内存分配的时间就占据了相当一部分，甚至影响性能

而SDS定义了len和free属性

- len**未必就是字符数量加一**
- free**记录了字节数组中未使用的空间**

由此引出了两种优化策略

#### 空间预分配



#### 惰性空间







































