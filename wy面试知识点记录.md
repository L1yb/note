## 排序算法

以下是对每个算法是否使用分治法思想的简要分析：

1. **快速排序 (Quick Sort)**：
   - **使用分治法**：快速排序通过选择一个“基准”元素，将数组划分为两个子数组（左边的元素都小于基准，右边的元素都大于基准），然后递归地对这两个子数组进行排序。这个过程符合分治法的定义。

2. **冒泡排序 (Bubble Sort)**：
   - **不使用分治法**：冒泡排序通过多次比较相邻元素并交换它们的位置，将每一轮排序中的最大（或最小）元素“冒泡”到序列的一端。这个算法是通过逐步的局部交换而非分治法的递归过程来实现排序的。

3. **归并排序 (Merge Sort)**：
   - **使用分治法**：归并排序首先将数组分成两个子数组，递归地对这两个子数组进行排序，然后合并这两个已排序的子数组。这个过程符合分治法的定义。

4. **二分查找 (Binary Search)**：
   - **使用分治法**：二分查找在每次比较后，将搜索范围分成两半（左半部分和右半部分），递归地在包含目标元素的部分继续查找。这也是分治法的应用。

结论

在给出的选项中，**冒泡排序** 是不使用分治法思想的算法。它是一种逐步交换和排序的算法，而不是基于将问题分解成子问题的分治策略。



## 烤面包

---

**题目描述**

小A每天都要吃两种面包a和b各一个。为了尽快吃到这两种面包，小A可以选择以下两种方案：

1. **使用两个不同的面包机**：选择两个不同的面包机分别制作面包a和面包b。花费的时间将是这两个面包机制作a和b面包所需时间的最大值。
2. **使用同一个面包机**：选择一个面包机来制作面包a和面包b。花费的时间将是这个面包机制作a面包的时间和制作b面包的时间之和。

输入：

- 第一行一个正整数 \( n \)\($1 \leq n \leq 10^5$\)，表示面包机的个数。
- 第二行 \( n \) 个正整数 \( $a_i$ \)\($1 \leq a_i \leq 10^5$\)，表示第 \( i \) 台面包机制作面包a所需的时间。
- 第三行 \( n \) 个正整数 \( $b_i $\)($1 \leq b_i \leq 10^5$），表示第 \( i \) 台面包机制作面包b所需的时间。

输出：

- 输出一行一个正整数，表示制作这两种面包所需的最少时间。

**示例**

输入：
```
3
2 4 6
3 5 7
```

输出：
```
5
```

**说明**

- 选择第一台面包机制作a面包，第三台面包机制作b面包，所需的时间为 max(2, 7) = 7。
- 选择第三台面包机制作a和b面包，所需的时间为 6 + 7 = 13。
- 所以最少时间是 5。





## 加一删除操作题

---

**题目描述**

给定一个长度为 \( n \) 的序列和一个整数 \( x \)，你可以进行以下两种操作：

1. 从序列中删除一个元素。
2. 将序列中的一个元素的值加一。

你的目标是使操作后的序列（可以为空）中数字之和是 \( x \) 的倍数。请计算至少需要多少次操作才能实现这一目标。

**输入描述**

- 第一行包含两个用空格隔开的正整数 \( n \) 和 \( x \)，分别表示序列的长度和整数 \( x \)。
- 第二行包含 \( n \) 个用空格隔开的正整数 \( A[1], A[2], \ldots, A[n] \)，表示序列中的 \( n \) 个元素的值。

**输出描述**

- 输出一行一个整数，表示使序列中数字之和是 \( x \) 的倍数所需要的最少操作次数。

**示例**

输入：
```
1 3
4
```

输出：
```
1
```

**示例解释：**

- 在这个例子中，总和是 4，目标是使其成为 3 的倍数。删除唯一的元素 4，使总和变为 0，正好是 3 的倍数。

输入：
```
3 5
1 3 3
```

输出：
```
2
```

**示例解释：**

- 在这个例子中，总和是 7，目标是使其成为 5 的倍数。可以通过删除一个 3，然后将 1 加一，得到的序列为 2 和 4，总和为 6（即 2 + 4），使总和变为 5 的倍数。总共需要 2 次操作。



在同一个进程的不同线程之间，以下内容不能被共享的是：

**C. 栈**

解释：

- **A. 全局变量**：全局变量在同一个进程的所有线程之间是共享的。所有线程都可以访问和修改全局变量。

- **B. 文件句柄**：文件句柄（或文件描述符）也是在同一进程的所有线程之间共享的。这是因为文件句柄是由进程内核维护的，线程共享进程的文件描述符表。

- **C. 栈**：每个线程都有自己的栈空间。栈用于存储线程的局部变量、函数调用信息等。线程之间的栈是独立的，因此栈不能被共享。

- **D. 堆**：堆是由进程管理的内存区域，所有线程都可以访问同一个进程的堆，因此堆是共享的。

综上所述，**栈**是不同线程之间不能共享的部分。





## 虚函数，继承

## 浅拷贝深拷贝



---