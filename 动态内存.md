# 动态内存 Dynamic memory

# 动态内存


## 一、动态内存与智能指针

​	new：在动态内存中为对象分配空间并返回一个指向该对象的指针

​	delete：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存

**新标准库提供两种智能指针：** 和常规指针的区别是能**自动释放所指对象**

 这两者的区别是：

​	**shared_ptr** 允许对各指针指向同一个对象

​	**unique_ptr** 独占所指对象

**weak_ptr**伴随类，弱引用，指向shared_ptr所管理的对象

> 都定义在 memory头文件



### 1 shared_ptr类

#### 创建智能指针

1. 必须指出可以指向的类型
2. 命名 shared_ptr<T> p1;
3. 默认初始化是空指针     

#### 使用

1. 解引用返回所指对象
2. 在判断条件中，检测为空；有指向，则为true
3. p.get() 返回保存的指针，如果释放了其对象，返回的指针中所指的对象消失
4. swap(p, q)    p.swap(q)  
5. make_shared<T>(args)   返回一个shared_ptr，指向动态分配的类型为T的对象。使用args初始化   //独有
6. shared_ptr<T> p (q)   p是q的拷贝，会**增加q**中的**计数器**   //独有
7. p = q 都是shared，保存的指针能互相转换，会**递减p**的引用计数，若p的引用计数变为0，**将原内存释放** //独有
| 表达式 | shared_ptr和unique_ptr都支持的操作 |
| ---| --- |
|shared_ptr<T> sp|空智能指针，可以指向类型为T的对象|
|unique_ptr<T> up||
|p|将p用做一个条件判断，若p指向一个对象，则为true|
|*p|解引用P，获得它指向的对象|
|p->mem| 等价于(*p).mem|
|p.get()|返回p中保存的指针，若智能指针释放了其对象，返回的指针所指向的对象就消失了|
|swap(p, q)|交换p ，q中的指针|
|p.swap(q)||

-----
| 表达式| shared_ptr独有的操作|
|---| ---|
|make_shared<T>(args)| 返回一个shared_ptr,指向动态分配的类型为T的对象。使用args初始化此对象|
|shared_ptr<T> p(q)|p是q的拷贝，会递增q中的计数器|
|p = q| p q都是shared_ptr，所保存的指针必须能相互转换，此操作会递减p的引用计数，递增q的引用计数，若p的引用计数变为0，则将其管理的原内存释放|
|p.use_count()|返回与p共享对象的智能指针数量|
|p.unique()|若use_count 为1 返回true，否则返回true|

####  make_shared 最安全的分配使用动态内存方法

定义在memory头文件中

```cpp
	shared_ptr<int> p1 = make_shared<int> (42) //创建值为42的int的shared_ptr
    shared_ptr<string> p2 = make_shared<string> (10,'a') //p2 指向值为42的string
    
```

- 传**递的参数必须能够用来初始化，必须初始化**

根据args构造对象，不传参数按照值初始化

**每个shared_ptr都有一个关联计数器，称为 引用计数，只要拷贝一个shared，计数器都会递增，赋予一个新的值或者被销毁（例如离开作用域）会递减，一旦计数器变为0，就会自动释放自己管理的对象**

>  tip：不是指针被释放，是指针所指对象被释放（因为已经不被引用了）



####  shared_ptr自动销毁所管理的对象

​	当指向一个对象的最后一个shared被销毁时，shared类会通过析构函数自动销毁此对象。

#### shared_ptr还会自动释放相关联的内存

​	例如，在函数体内创建并初始化一个智能指针，那么离开函数体，所指向的内存就被释放了。

​	如果，这个shared_ptr作为返回值返回，引用计数递增，那么所指向的内存不会被释放

- **对于一块内存，shared_ptr只有在保证没有任何对象使用它时，才会释放它**

​	note：如果将shared放入一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不在需要的那些元素



#### 使用了动态生存期的资源的类

​	程序使用动态内存的原因：

1. 程序不知道自己需要多少对象 （容器类）
2. 程序不知道所需对象的准确类型
3. 程序需要在多个对象之间共享数据

​	目前为止，我们使用的类分配的资源都与对应对象生存期一致。例如，vector分配的元素只有当这个vector存在时才存在。当vector被销毁时，其中的元素也被销毁。

```cpp
vector<string> v1;
{//new scope
    vector<string> v2 = {"live", "in", "v2"};
    v1 = v2; //v1 copy v2
}// v2 is destroyed, and its elements are alse destoryed.
//v1 have three elements copied from v2
```

​		v2虽然被销毁，但是v1中有这些元素的拷贝。

但是，某些类分配的资源具有与原对象独立的生存期，例如Bolb对象不同拷贝之间共享相同的元素，即, **引用相同的底层元素**

```cpp
Bolb<string> b1;
{//new scope
    Bolb<string> b2 = {"live", "in", "b2"};
    b1 = b2; //b1 and b2 share elements
}// b2 is destoryed,but the elements within b2 are not destoryed
// b1 point to the elements initially created by b2

```

b2 被销毁，但是b1指向了这些元素，b1仍在使用。

​	一般而言，如果两个对象共享底层数据，当某个对象被销毁时，不能单方面销毁底层数据



#### 定义StrBlob类

设计思路：

- 使用标准库容器来管理元素，vector，
- 直接使用vector的话，如果数据存储在其中一个Blob对象b1中，当b1离开作用域，vector将被销毁
  例如：class Blob { vector<T> v1};
- 为了将其数据保存，将vector存在动态内存中，设置一个shared_ptr来管理vector的分配，shared_ptr将记录有多少StrBlob对象共享相同的vector,并在没有使用者时销毁vector
- 提供操作。我们会修改访问这些元素。如果用户试图访问不存在的元素，会抛出一个异常
- 默认构造和构造函数，接受单一initializer_list<string> 参数



#### 小结

在StrBlob类的设计中，提到了

1. 关于设计const版本的问题
   有些函数，本身不会修改成员的信息，可以把他设置成const成员函数，这样的好处是，如果用户创建了const类对象，依然能够有调用成功。
   在课后习题中有个问题，**是否需要const版本的push_back和pop_back(overload)**,这是一个逻辑问题，如果是**const对象，那么意味着它的成员数据是不可修改的**，定义const版本的push和pop函数，虽然能够实现push和pop的功能，和符合编译器的规则，但是违背的const对象本身的逻辑，所以不需要。**但是！如果成员是指针**，push和pop并不修改当前const对象的成员数据，**因为并未改变指向**，**只是修改指针所指的对象**，这么一来，似乎又符合逻辑了。
   关于刚才的思考似乎并没有绝对的对错，只由设计者自己决定，但是我倾向于不设计const的push和pop，既然是const对象，在初始化时定义好之后便不再修改了。（还不会更深入的操作之前就这么搞）



### 2 直接管理内存 new、 delete

在学习拷贝之前，除非使用智能指针来管理内存，否则不要分配动态内存。

new : 分配内存

delete： 释放new分配的内存

tip：容易出错，智能指针更容易调试

#### 使用new动态分配和初始化对象

自由空间分配的内存是无名的，new无法为其命名，而是返回一个指向它的指针。

int *p = new int;

**初始化**

1. 动态分配的对象是**默认初始化**的， 内置类型和组合类型是未定义的，类类型由构造函数决定

2. 可以使用**直接初始化**定义初始值
   ```cpp
   int *p = new int(1024);
   int *str = new string(10,'a');
   vector<int> *pv = new vector<int>{1,2,3,4,5,6,7,8,9};
   ```

3. 也可以**值初始化**,在类型名后加（）即可；
   ```cpp
   int *p0 = new int; //默认初始化，值未定义
   int *p2 = new int(); //值初始化，值为0
   int *str0 = new string; //默认初始化为空
   int *str1 = new string();//值初始化为空
   ```

4. 单一类型初始化器可以使用auto
   ```cpp
   auto *p1 = new auto (obj);//obj是单一类型 
   ```

   

对于有默认构造的类型，默认初始化和值初始化没有区别，都是调用**默认构造函数**；

但是没有默认构造的类型，默认初始化的值是未定义的；

**所以建议都使用值初始化！**



#### 动态分配const对象

const对象必须初始化，new可以为const对象分配内存，分配的对象是const的，new返回的是指向const的指针（point to const）



#### 内存耗尽

如果内存耗尽，会抛出一个错误，bad_alloc。给new传递一个**标准库对象**nothrow，就不会报错，会返回一个空指针，这种形式的new被称为定位new（placement new）。

bad_alloc 、nothrow都定义在头文件new中。

```cpp
int *p1 = new int;
int *p2 = new(nothrow) int;
```

 

#### 释放动态内存

delete表达式接受一个指针，指向我们要释放的对象，会执行两个动作：

- 销毁给定指针指向的对象
- 释放对应的内存



#### 指针值和delete

传递给delete的指针**必须指向动态分配的内存（new分配的）**，或者一个空指针，**不能重复释放**

const对象同样可以delete指向它的指针来销毁它。

**##一般情况下编译器并不能区分指针指向的是静态的还是动态分配的，也不能区分指针所指的内存是否已经被释放了，编译时一般会通过，尽管他们是错误的**



#### 动态对象的生存期直到被释放为止

#### 空悬指针（dangling pointer）

**delete释放指针后**，指针失效了，但是很多机器上这个指针依然保留着动态地址，这样的指针叫 空悬指针，即，指向一块曾经有效 但现在已经无效的内存 的指针。

#### 小结 使用动态内存非常容易出错

1. 忘记delete内存，也就是常说的“内存泄漏”，因为这种内存“永远”不可能会被还给自由空间了。malloc分配的都是假的，malloc的请求系统都知道，在程序结束后，系统会回收malloc的所有资源
2. 使用已经释放的对象
3. 同一内存释放两次。当多个指针指向相同动态分配的对象时，可能发生。

**best practices：坚持只是用智能指针**



### 3 shared_ptr和new结合使用

 1. 可以使用new返回的指针初始化智能指针

 2. 智能指针**接受指针参数**，构造函数是**explicit的**，不能将内置指针隐式的转换为智能指针，**必须使用直接初始化**
    ```cpp
    shared_ptr<int> p1 = new int(42); //错误，不能隐式转换
    shared_ptr<int>p1(new int(42)); //正确，直接初始化
    ```
|表达式 | 语法|
|--- | --- |
| shared_ptr<T> p(q) | p管理内置指针q所指的对象；q必须指向new分配的内存，并且能够转换为T* |
| shared_ptr<T> p(u) | p从unique_ptr u那里接管对象的所有权；将u置为空 |
| shared_ptr<T> p(q, d) | p 将调用 d 来替代delete |
|  shared_ptr<T> p(p2, d) | p 是p2的拷贝  |
| p.reset()| 若p是唯一指向其对象的智能指针，reset会释放此对象，将p置空|
|p.reset(q)|令p指向q，delete释放q|
|p.reset(q, d)|还会调用d替代delete释放q|



#### 不用混合使用智能指针和普通指针

体会下面的例子

~~~cpp
void process(shared_ptr<int> p1) {
    ...//使用p1
}//p1离开作用域，p1被销毁
~~~

正确的用法

~~~cpp
shared_ptr<int> p2(new int(42));//计数加一，为1
process(p2);//拷贝，计数加一，为2
//计数减一，为1  
int i = *p2;//引用计数为1

~~~

错误例子

```cpp
int *x(new int(42));
process(s); //错误，不能隐式转化
process(shared_ptr<int>(x));//正确，但是x的内存会被释放 
int i = *x;//错误，x是空悬指针
```

将一个shared_ptr与一个普通指针绑定之后，就将这块**内存的管理权限交给了shared_ptr**,一旦这样做了，就**不能再使用普通指针来访问这块内存了**，因为编译器不知道它什么时候被销毁。



**也不要使用get初始化另一个只能指针或为智能指针赋值**

get返回一个普通指针，指向智能指针所管理的内存，这个函数是为这种情况设计的：**为不能使用智能指针的代码传递一个内置指针。**使用get返回的指针不能使用delete此指针。

```cpp
shared_ptr<int> p1(new int(42));
int *p2 = p1.get();//p2指向p1管理的内存
{
    shared_ptr<int> (p2);//两个独立的智能指针指向同一块内存
}//离开作用域，p2被销毁，所指的内存被释放
int foo = *p1; //行为未定义
```

333这段有点晕

===============================================

题目的意思应该是这样：用get返回的指针初始化另一个智能指针

```cpp
shared_ptr<int> p1(new int(42));
int *p2 = p1.get();//p2指向p1管理的内存
{
    auto p3 = shared_ptr<int> (p2);
}//p3离开作用域，p3被销毁，所指的内存被释放,double free
int foo = *p1; 
```

虽然，vscode编译器能运行不报错，但是vs会报错double free

不管编译器怎么说，这个问题的关键是，**不能用get返回的指针去初始化智能指针，或者为其他智能指针赋值**





#### 检查是不是唯一用户

reset配合unique使用

```cpp
if (!p.unique()) {
    p.reset(new string (*p));
}
*p += newVal;//确定是唯一用户了，可以修改值了
```



#### 小结

p415课后习题常错点

1. 智能指针和普通指针绑定，导致的**double free**，以及**产生空悬指针**
2. **get返回的row point不能delete**
3. **普通指针不能隐式转换成智能指针**，new T()返回的是普通指针，传递给要求智能指针参数的函数会报错



### 4 智能指针和异常

在函数中，如果普通指针再delete之前发生了异常，导致内存没有释放，但是如果是智能指针，离开作用域之后会再次检查引用计数，就有可能释放掉不用的内存

#### 智能指针和哑类

> "哑类"（Dummy Class）通常是指一个没有实际功能、只是为了占位或者作为框架的一部分而存在的类。这样的类通常只有最基本的结构，可能包含默认的构造函数、析构函数，但它们的主要目的是为了满足某些编程规范或框架的需求。
>
> 哑类可能是一个临时性的实体，只是为了占据某个类的位置，或者作为接口的一部分。在实际编码中，有时会创建哑类来填充一些代码结构，以后可能会添加功能。在设计初期，它可以是一个占位符，让开发者有一个代码结构上的蓝图，而在以后的迭代中再逐步完善。
>
> 这个术语的具体含义可能会因上下文而异，但总体来说，哑类是一种不具备实际业务逻辑的、主要用于框架或代码结构的类。



#### 注意：智能指针陷阱

智能指针必须坚持的规范：

- 不使用相同的内置指针 **值初始化（或reset）**多个智能指针

- **不delete get（）返回的指针**
- **不使用get（）初始化或reset另一个智能指针**
- 如果使用了**get返回的指针**，记住**当最后一个对应智能指针销毁后，指针就变得无效了**
- 如果使用智能指针管理的资源**不是new分配的内存**，记住传递给他一个**删除器**（deleter）

​	

### 5 unique_ptr

unique_ptr“拥有”它所指向的对象，某个时刻，只能由一个unique_ptr指向一个给定对象，当它被销毁时，所指的对象也被销毁

- 定义时，需要将其绑定到new返回的指针上

- **初始化必须采用直接初始化**

  ~~~cpp
  unique_ptr<int> p1;
  unique_ptr<int> p2(new int(42));
  ~~~

- **不支持普通拷贝或辅助**

  ```cpp
  unique_ptr<string> p1(new string("hello"));
  unique_ptr<string> p2(p1);//错误
  unique_ptr<string> p3;
  p3 = p1;//错误
  ```

   
|表达式|解释|
|---| ---|
|unique_ptr<T> u1| 空unique_ptr 可以指向类型为T的对象；u1会使用delete来释放它的指针|
|unique_ptr<T, D> u2| u2会使用类型为D的可调用对象来释放它的指针|
|unique_ptr<T, D> u(d)  | 空unique_ptr，指向类型为T的对象，用类型为D的对象d替代delete|
| u = nullptr | 释放u指向的对象，将u置空|
|u.release()| u**放弃对指针的控制权**，返回指针，并将u置空 |
|u.reset()|释放u指向的对象|
|u.reset(q)|如果提供内置指针，u指向这个对象，否则置空|
|u.reset(nullptr)| |

使用：

- 控制权的转移：

```cpp
unique_ptr<string> p2(p1.release()); //release将p1置空，将控制的对象转移给p2
unique_Ptr<string> p3(new string("hello"));
p2.reset(p3.release()); //p2释放原本控制的内存，接手p3返回的指针指向的内存，并将p3置空
```

- release()需要有另一个智能指针接受他的参数，否则就会丢失那块内存的指针
  `p2.release() //丢失了p2指向的内存的指针`

#### 传递unique_ptr参数和返回unique_ptr

不能拷贝unique_ptr的规则有一个**例外**：

- 可以拷贝或赋值一个**即将被销毁的unique_ptr**，例如从**函数返回unique_ptr**

```cpp
unique_ptr<int> func(int p) {
    //...
    return unique_ptr<int>(new int(p))
}
```



#### 向unique_ptr传递删除器

我不到啊

#### 小结

unique_ptr拥有内存的唯一控制权（可以转让），只能直接初始化，不能拷贝或赋值（除了即将被销毁的unique_ptr）

```cpp
int ix = 1024, *pi = &ix, pi2 = new int(1024);
typedef unique_ptr<int> IntP;
IntP p0(ix);//错误，ix不是指向内存的指针
IntP p1(pi);//编译通过，运行报错，当p1离开作用域调用delete函数时，pi不是new出来的内存
IntP p2(pi2);//编译通过，运行报错，unique_ptr必须直接初始化，会释放原始指针所指向的对象
IntP p3(&ix);//同pi
IntP p4(new int(1024);//推荐
IntP p5(p2.get());//两个unique_ptr指向同一块内存，double free

```



--------



### 6 weak_ptr

- weak_ptr是一种**不控制所指对象生存期的智能指针**，它指向一个weak_ptr管理的对象。

- 将weak_ptr绑定到shared_ptr上**不会改变shared_ptr的引用计数**。
- **当最后一个指向对象的shared_ptr被销毁，无论weak_ptr是否指向，对象都会被释放**
- “弱”共享

|表达式 |语法 |
|---| ---|
|weak_ptr<T> w|空weak_ptr可以指向类型为T的对象|
|weak_ptr<T> w(sp)|与shared_ptr sp指向相同的对象|
|w = p| p可以是shared_ptr或weak_ptr,赋值共享对象|
|w.reset()|将w置空|
|w.use_count()|与w共享对象的shared_ptr的数量|
|w.expired()|若w.use_count()为0,返回true,否则返回false(过期的)|
|w.lock()|如果expired()为true,返回一个空的shared_ptr,否则返回一个指向w的对象的shared_ptr|

```cpp
shared_ptr<string> sp(new string(azha));
weak_ptr<string> wp(sp);
```

因为指向的对象可能不存在,所以不能通过weak_ptr直接访问,要通过lock()

```cpp
if(shared_ptr<string> np = wp.lock()}) {//如果np不为空,条件成立
    //np和sp共享对象
}
```

#### 核查指针类































