# 一、 常见问题

## 1.1 HTTP基本概念

HTTP是超文本传输协议

**超文本是什么？**

文本：字符文字、图片、视频、压缩包

超文件：是文字、图片、视频等的混合体，**最关键的是有超链接**，能从一个超文本跳转到另一个超文本

HTML就是一个常见的超文本

> **HTTP 是一个在计算机世界专门在两点之间传输超文本数据的约束和规范**

### 1.1.1 常见的状态码有哪些？

![image-20241220145645294](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241220145645294.png)

2XX表示服务器成功处理了客户端的请求

- **200 OK**：表示一切正常，如果是 非HEAD请求，服务器返回响应头有body数据
- **204 No Content**：表示一切正常，响应头没有body数据
- **206 Partial Content**：是应用于HTTP分块下载或断点续传，表示响应的body数据不是全部，而是其中一部分，也表示成功处理

3XX表示客户端请求的资源发生了变化，需要客户端用新的URL重新发送请求获取资源，**重定向**

- **301 Moved Permanently**：表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- **302 Found**：表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

​	301 和 302 都会在响应头里使用字段location，指明后续要跳转的URL，浏览器会自动重新定向新的URL

- **304 Not Modified**：不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

4XX状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。

- 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。

- 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

5XX状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 「**500 Internal Server Error**」：与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。

- **501 Not Implemented**：表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思

- **502 Bad Gateway**通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。

- **503 Service Unavailable**表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

### 1.1.2 HTTP常见字段有哪些？

1. host字段：客户端发送请求时用来指定服务器域名
2. Content-Length字段：表明本次回应的数据长度
   这是为了解决粘包问题，HTTP协议设置回车符、换行符作为header的边界，通过Content-Length作为body边界
3. Connection字段：常用于客户端请求服务器使用**HTTP长链接**机制，便于复用
4. Content-Type 字段：用于服务器回应时，告诉客户端本次数据是什么格式
5. *Content-Encoding 字段*：说明数据压缩方法，表示返回的数据使用了什么压缩格式



## 1.2 GET和POST

### 1.2.1 区别

**GET的语意是从服务器获取指定的资源**，GET请求的参数位置一般是写在URL中，URL规定只支持ASCII，所以get请求的参数只允许ASCII字符，而且浏览器对URL的长度有限制（http协议对url场地没有规定）

**POST的语意是根据请求负荷（报文body）对指定的资源作出处理**。post请求携带数据的位置是报文的body，body中的数据可以是任何类型，浏览器不会对body的大小做出限制

### 1.2.2 GET和POST方法都是安全和幂等的吗

**安全**是指请求方法不会破坏服务器上的资源

**幂等**指的是多次执行相同的操作，结果都是相同的

按照**RFC规范**定义的语意来说：

- GET方法就是安全且幂等的，因为他是只读操作，可以对GET请求的数据做缓存，这个缓存可以做在浏览器本身上，也可以做在代理上，而且浏览器中的GET请求可以保存为书签

- POST因为是新增或者提交数据，会修改服务器上的资源，所以是不安全的；且多次提交数据就会创建多个资源，因此是不幂等的，所以浏览器一般不会缓存POST请求，也不能把POST请求作为书签

但是实际中，并不一定按照RFC规范的语意来实现POST和GET，比如：

- 可以用GET方法实现新增和删除数据的请求
- 可以用POST实现查询数据的请求

因为HTTP传输的内容都是明文，所以只要抓个包就能看到，为了避免数据被窃取，就要使用HTTPS协议，这样所有HTTP的数据都会被加密传输



## 1.3 HTTP缓存技术

### 1.3.1 HTTP缓存有哪些实现方式？

对于一些具有重复性的HTTP请求，可以把这对请求-响应的数据都存在在本地，下次可以直接读取本地数据，不必通过网络获取服务器响应了

缓存有两种方式：

- 强制缓存
- 协商缓存

### 1.3.2 强制缓存

强制缓存指的是 只要浏览器判断缓存没有过期，就直接使用浏览器的本地缓存，决定是否使用缓存的主动性在浏览器

强制缓存是利用一下两个HTTP响应头部字段实现的

- Cache-Control，相对时间
- Expires：绝对时间

如果同时存在的话，**相对时间优先级高于绝对时间**

Cache-Control实现的流程是：

- 当浏览器第一次访问服务器资源时，服务器会返回这个资源的同时，在Response Header添加Cache-Control，其中设置了过期时间
- 浏览器再次访问的时候，会**先通过请求资源的时间与Cache-Control中设置的过期时间大小，计算该资源是否过期**，如果没有过期，就是用该缓存，否则就向服务器重新申请
- 服务器再次收到请求后，会更新Response Header中的Cache-Control

### 1.3.3 协商缓存

浏览器某些请求的响应码是304，服务器这是在告诉浏览器可以使用本地缓存的资源，这就是协商缓存

![image-20241220214854619](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241220214854619.png)

协商缓存基于两种头部来实现：

1. 第一种方式是**基于时间**，请求头部中的If-Modified-Since 字段与响应尾部的Last-Modified字段实现

- Last-Modified：标识这个响应资源的最后修改时间
- If-Modified-Since：**当资源过期了**，发现响应头部中具有Last-Modified声明，**则再次发送请求的时候带上Last-Modified的时间**，服务器收到请求后发现If-Modified-Since则与被请求资源的Last-Modified进行对比，如果修改时间比较新，说明被修改过，则返回最新资源（HTTP 200 OK）；如果资源无新的修改，响应HTTP 304走缓存

2. 第二种方式是基于一个**唯一标识ETag**，请求头部中的if-None-Match和响应头部的ETag

- ETag:唯一标识响应资源
- if-None-Match：**当资源过期时**，浏览器发现头部有ETag，**则再次向服务器发起请求时会将if-None-Match值设置为ETag的值**。服务器收到请求回进行对比，没有变化就返回304，变化了就返回200

相比而言：后者更能准确的判断文件是否被修改过，避免存改时间导致不可靠

> 图片中的过期从何而言？协商缓存的标准是是否被修改。这个问题在下面就被解答了，因为只有强制缓存过期了，再回请求协商缓存
>
> 那又有一个问题了，如果没过期，但是文件变动了怎么办？

如果请求中同时携带了Last-Modified和ETag，**ETag的优先级更高**，然后在看Last-Modified，理由如下：

1. 没有修改文件，最后修改时间也可能发生变化
2. 有些文件是在秒级以内修改的，If-Modified-Since等检查到的粒度就是秒级的，使用ETag可以允许客户端在一秒内多次修改
3. 有些服务器不能准确的获取文件的最后修改时间

**注意：协商缓存这两个字段都需要配合强制缓存中的Cache-Control来使用，只有在未能命中强制缓存的时候，才能发起协商缓存请求**

![image-20241220220936293](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241220220936293.png)

## 这里引入一个问题：如果强制缓存没过期，但是文件修改了，会发生什么？

显然，浏览器依然会优先读取本地缓存数据，新数据客户端无法得知

解决方法有三个：

1. 更改文件的URL，添加版本号或者哈希值，成为一个新的URL
   **这里就有新问题了，那如果每次都修改URL，完全没用到缓存，就不是缓存技术了**
   上面这个疑问明显是不得其法~
   解答：当资源修改之后，更改URL，使得URL变得像ETag一样唯一标识资源，但是变动的资源视为新资源，使用新的URL，**原本的URL访问服务器可能会404**，对此需要配套**设置重定向的映射表**
   - 使用场景：静态资源（如 JS（负责网页行为）/CSS（负责网页样式、美化）/图片）

2. 将更新时间设置的小一点，**使用短强制缓存+协商缓存**
3. **服务端推送机制**：对于高级使用场景，服务器可以在资源变动后主动告知客户端

## 1.4 HTTP特性

目前为止 ，常见的版本有HTTP/1.1,HTTP/2.0, HTTP/3.0 不同版本有不同的特性

### 1.4.1 HTTP/1.1的优点有哪些

1. 简单
   基本报文格式就是header+body，头部信息是key-value简单报文格式
2. 灵活和易于拓展
   HTTP协议里的各类请求方法、URL、状态码、头字段等组成部分要求都没有固定死，允许开发人员自定义和扩充
   同时HTTP由于是工作在应用层，它的下层可以随意变化，比如
   - HTTPS就是在HTTP和TCP之间增加了SSL/TLS安全传输层
   - HTTP/1.1和HTTP/2.0传输协议使用的是TCP协议，而HTTP/3.0改用了UDP协议
3. 应用广泛和跨平台
   从台式机的浏览器到手机app，http的应用遍地开花，同时天然具有跨平台的优越性

### 1.4.2 缺点有哪些

两把双刃剑：无状态、明文传输；一个缺点：不安全

1. 无状态
   好处：服务器不需要记录http的状态信息，减轻服务器负担

   坏处：在完成关联性的操作时非常麻烦；例如，登录-》下单-》结算-》支付，每一步都需要知道用户信息，但是之所以没有重复登录使用了其他技术，其中应用最广泛的是**cookie技术**，cookie会通过在请求和响应报文中写入cookie信息来控制客户端的状态（相当于客户端第一次接收到客户端请求好，就会在响应中添加cookie信息，之后的每次请求都会带着cookie身份信息）

2. 明文传输
   好处：使用wireshark抓包可以直接查看，**对于调试非常便利**

   坏处： **信息裸奔**容易被窃取

3. 不安全

   - 通信使用明文：容易被窃取
   - 不验证通信方身份：遇到伪装无法识别
   - 无法验证报文的完整性：内容可能被篡改、植入广告

### 1.4.3 性能

HTTP的协议是**TCP/IP**，并且使用了**请求-应答** 的通信方式，所以性能的关键就在这两点

1. **长连接**

![image-20241223170901759](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241223170901759.png)

2. **管道网络传输**

因为采用了长连接，使得管道传输成为可能，即，可以在同一个TCP连接中，客户端发送多个请求

## 1.5 http和https

### 1.5.1 区别

| | http|https |
|---|---|---|
|安全性|明文传输，不安全|在tcp层和http网络层之间添加了SSL/TLS安全协议，安全|
|建立连接|TCP三次握手之后即可传输|TCP三次握手，SSL/TLS握手后加密传输|
|默认端口|80|443|
|可信度||向CA申请数字证书，确保服务器可信|

### 1.5.2 https解决了http的哪些问题
http明文传输存在的风险
- 窃听风险，窃取通信内容
- 篡改风险，篡改网页信息植入广告
- 冒充风险，冒充消费网站

![image-20241224151316791](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241224151316791.png)

**HTTPS  在tcp层和http网络层之间添加了SSL/TLS安全协议**

- 信息加密：无法被窃取
- 校验机制：无法篡改内容，篡改了就无法显示
- 身份证书：证明打开的淘宝是淘宝

如何做到的呢？

1. **混合加密**

![image-20241224151610944](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241224151610944.png)

- 在通信建立之前采用**非对称加密**交换**会话密钥**
- 通信过程中全部使用**对称加密**的会话密钥加密明文数据

混合加密的原因：

- 非对称加密：公钥和私钥，公钥可以随意分发，私钥保密
- 对称加密只是用一个密钥，运算速度快

2. **摘要算法+数字签名**

使用**摘要算法（哈希函数）**来计算出内容和哈希值，哈希值是唯一的，无法通过哈希值推到内容

**通过哈希值可以确保内容不会内替换，但是不能保证内容+哈希值不会被整个替换**，所以需要服务器的证明

非对称加密的两个密钥：

- 公钥：公开给所有人
- 私钥：本人掌握，不可泄露

这两个密钥是可以双向解密的，彼此互相解密

- **公钥加密，私钥解密**：确保传输内容安全
- **私钥加密，公钥解密**：确保消息不会被冒充，公钥如果能解开，说明信息的来源一定是私钥的持有者

非对称加密的主要用途就是**私钥加密，公钥解密**确认身份，加密的内容不是消息内容本身，**而是对哈希值加密**

![image-20241224152944058](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241224152944058.png)

3. **数字证书**

目前来说：

- 使用哈希算法保证内容的完整性  
- 通过非对称加密保证信息来源的可靠性（能确认是私钥持有方发送的）

现在还有一个问题是：如果公钥是被伪造的呢

![image-20241225132934359](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241225132934359.png)

### 1.5.3 HTTPS是如何建立的

SSL/TLS协议基本流程：

- 客户端向服务器索要并验证服务器的公钥
- 双方协商生产 回话密钥
- 双方采用会话密钥进行加密通话

前两步是TLS握手阶段，涉及四次通信，使用不同的密钥交换算法，TLS握手流程也不一样，常用的密钥交换算法有两种：**RSA算法和ECDHE算法**

TLS握手过程（协议建立的详细流程）：

1. **clientHello**

客户算向服务器发起加密通话请求，包含以下信息：

- 客户端支持的TLS协议版本
- 客户端生成的随机数
- 客户端支持的密码套件列表，例如RSA加密算法



2. **ServerHello**

服务器手打扫客户端请求后，向客户端发出响应，也就是ServerHello，包含如下信息

- 确认TLS版本，如果浏览器不支持，则关闭加密通信
- 服务器产生随机数
- 确认密码套件列表
- 服务器数字证书

3. **客户端回应**

客户端收到回应后，会通过浏览器或者操作系统的CA公钥，确认服务器数字证书的真实性，从数字证书中取出服务器的公钥，加密报文，向服务器发送信息：

- 一个随机数，**该随机数会被服务器公钥加密**
- 加密通信算法改变通知，表示后续信息都是用**会话密钥**加密
- 客户端握手结束通知，表示客户端的握手阶段已经结束，同时，把之前所有内容发生的数据做个摘要，供服务器校验

上面产生了三个随机数，会发送给服务器，**服务器和客户端拥有三个相同的随机数，并依据此生成会话密钥**

4. **服务器的最后回应**

服务器收到客户端的第三个随机数以后，通过协商的加密算法，计算出本次通话的**会话密钥**，最后向客户端发送如下信息：

- 加密通信算法改变通知，表示后续信息都是用会话密钥加密
- 服务器握手结束通知，表示服务器握手阶段结束，并生成摘要供客户端校验

> 至此后续通话都使用普通的**HTTP**协议，只不过内容都使用了**会话密钥**

### 1.5.4 客户端是如何校验数字证书的

![image-20241225140259475](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241225140259475.png)

CA证书签发过程：

服务端：

- 会将持有者的公钥、用途、颁发者、有效时间等打包成一个**包**
- 使用hash算法对包进行计算得到一个哈希值
- CA使用**自己的私钥**对这个**哈希值进行加密**，也就是CA签名
- 然后将 包 加上 签名，数字证书就做好了

客户端：

- 同样使用hash算法对**包**计算得到**哈希值H1**
- 然后从系统或者浏览器取出**CA的公钥**解出CA签名加密的**哈希值H2**
- 然后对比H1 H2是否相同

### 1.5.5 https的应用数据是如何保证完整性的

TLS在实现上分为 握手协议和记录协议两层：

- 握手协议也就是四次握手的过程，负责协商加密算法和生成对称密钥，后续使用此密钥来保护应用程序数据
- 记录协议主要负责消息（http数据）的压缩、加密、认证，过程如下

![image-20241225142144678](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241225142144678.png)

这个mac值是哈希算法生成的，用来保证数据的完整信

### 1.5.6 HTTPS一定安全可靠吗

除非客户端认证了中间人的证书，中间人想要抓包、转发数据，必须得到客户端的认证，想要被认证就要将自己的证书写入到系统里，这里产生的不安全，是客户端操作导致的，https本身没有任何漏洞

## 1.6 HTTP/1.1、 HTTP/2、 HTTP/3的演变

### http1.1 和http1.0相比做出的提升

- 长连接
- 管道传输

性能瓶颈：

- 请求/相应头部未经压缩就发送，首部信息越多延迟就越大，只能压缩body部分
- 发送冗长的首部。每次互相发送相同的首部造成的浪费越多
- 服务器是按照请求的顺序相应的，如果服务器响应慢，会导致客户端一直请求不到数据，也就是**队头堵塞**
- 没有请求优先级控制
- 请求只能从客户端开始，服务器只能被动响应

### http2的优化

http2是基于https的，所以有安全性的保证

![image-20241225150038300](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241225150038300.png)

做出的改进：

1. **头部压缩**

HTTP2会压缩头，如果同时发出多个请求，他们的头部是相同的，http2会消除重复部分，也就是HPACK算法：在客户端和服务器同时维护一张头信息表，所有字段都是存入这个表，生成一个索引号，避免发送重复字段，只发送索引号，提高速度

2. **二进制格式**

http2不在使用纯文本格式的报文，而是全面采用二进制格式，头信息和数据体都是二进制，并成为帧，提高传输效率

3. **并发传输**

上面提到的队头堵塞问题，HTTP2引入了stream概念，多个stream复用在一条TCP连接

**针对不同的HTTP请求用独一无二的stream ID区分，接收端可以通过streamID *有序组装* HTTP消息，不同stream的帧可以乱序发送，因此可以并发不同的stream，也就是HTTP2可以并发交错发送请求和响应**

4. **服务器推送**

http2在一定程度上改善了传统的 请求-应答 工作模式，服务器可以主动的向客户端发送消息

服务器和客户端双方都可以建立stream，客户端streamID必须是奇数，服务器是偶数

![image-20241225151342652](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241225151342652.png)

在客户端访问HTML时，服务器可以主动推送CSS文件，减少消息传递次数

**缺陷**：

http2依然有队头阻塞问题，只不过存在于TCP层，**http2时基于TCP协议来传输数据的，TCP时字节流协议，TCP必须保证收到的字节数据时完整且连续的，这样内核才会将缓冲区的数据返回来http应用，那么当前一个字节没有到达时，后收到的字节数据只能存放在缓冲区里等待着一个字节的到来才能从内核中取到数据**

![image-20241225151820636](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241225151820636.png)

传输过程中丢了一个包，就会出发TCP重传机制，这样后续的包虽然已经到达了缓冲区，但是所有的http请求都必须等这个包重传回来才能被应用层读取。

### http3做了哪些优化

http1.1 http2 都没彻底解决的队头阻塞的问题，http3解决了

- http1.1虽然使用了**管道传输**，**解决了请求的队头阻塞，但是没有解决响应的队头阻塞**，因为服务器需要按顺序响应请求，如果服务器对某个请求响应的时间过长，后续都必须等他响应完
- http2通过**多个请求复用一个TCP连接**解决了http队头阻塞，但是**一旦丢包，就会阻塞所有的http请求，这是TCP层的阻塞**

![image-20241225152442321](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241225152442321.png)

http2队头阻塞是因为TCP，所以http3将http下层的TCP协议改成了UDP

UDP不管发送顺序，也不管丢包，UDP不是可靠传输，但是基于UDP的**QUIC协议**可以实现**类似TCP的可靠性传输**

QUIC有三个特点：

1. **无队头阻塞**

QUIC也有类似HTTP2 stream与多路复用的概念，可以在一条连接上并发传输多个stream，一个stream可以视为一个http请求

当某个stream发生丢包时，只阻塞这个stream，其他stream不会受到影响，

![image-20241225152843638](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241225152843638.png)

2. **更快的建立连接**

对于http1 和http2，TCP和TLS时分层的，分别属于内核实现的传输层、openssl库实现的表示层，因此他们呢很难合并到一起，需要分批次握手，先TCP握手，然后TLS握手

HTTP3需要QUIC握手，这个过程只需要1RTT，握手的目的是确认双方的连接ID，连接迁移就是基于连接ID实现的

但http3的QUIC并不是和TLS分层，而是QUIC包含TLS，它在自己的帧会携带TLS的记录

![image-20241225154742520](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241225154742520.png)

3. **连接迁移**

基于TCP传输协议的HTTP协议是通过四元组确定一条TCP连接，当移动设备的网络从4G切换到WiFi，意味着IP地址变了，那就要断开连接，重新建立连接

![image-20241225154826048](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241225154826048.png)

而QUIC协议没有使用四元组绑定连接，而是通过**连接Id**来标记通信的两个端点，服务器和客户端各自选择一组id标记自己，因为当设备的网络变更了以后，ip地址变化，只要仍保有上下文信息（连接id、TLS密钥），就可以无缝复用原连接，消除重连的成本，没有丝毫卡顿，打到了连接迁移的功能

所以QUIC是一个在UDP之上的伪TCP+TLS+HTTP/2的多路复用协议



# 二、http/1.1如何优化

- 尽量避免发送http请求
  - 缓存
- 在需要发送http请求时，考虑如何减少请求次数
  - 减少重定向请求次数
  - 合并请求
  - 延迟发送请求
- 减少服务器的http响应的数据大小
  - 无损压缩
  - 有损压缩

## 1、如何避免发送http请求

客户端会将第一次响应的数据存在本地，将其中的url当做key，将响应当做value

**如果缓存的响应不是最新的，如何处理**

见1.3 http缓存技术



## 2、 如何减少http请求次数

### **减少重定向请求次数**

> 重定向请求：资源的URL变动，想要获取资源需要重新请求新的URL，会增加http请求

<img src="https://raw.githubusercontent.com/L1yb/PICGO/main/image-20250102143754342.png" alt="image-20250102143754342" style="zoom: 67%;" />

1. 将重定向的任务交给代理服务器做，能减少客户端的URL2的请求，返回URL2的资源
2. 当代理服务器知道重定向的规则以后，还能进一步减少请求

<img src="https://raw.githubusercontent.com/L1yb/PICGO/main/image-20250102144058535.png" alt="image-20250102144058535" style="zoom:67%;" />

### 合并请求

将多个访问小文件的请求合并成一个大请求，减少重复发送http头部

方式：

- 合成多个小图片成一个大图片
- 客户端使用webpack等打包工具
- 使用base64编码图片的二进制数据，以URL形式嵌入到html中一起发送

合并存在的问题是，如果一个小资源发生变化要重新下载整个完整的合并资源



### 如何减少http响应的数据大小

**无损压缩**

首先，取出空格和换行

接着无损压缩：对资源建立统计模型，**将常出现的数据用较短的二进制比特序列标识，将不常出现的用较长的比特序列标识**，生成二进制比特序列一般是**霍夫曼编码**

**有损压缩**

舍弃次要数据，减少数据量，常用于音频、视频、图片



## 3、 HTTPS RSA握手解析

​     	![image-20250102150104438](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20250102150104438.png)



### TLS握手过程

见1.5

![image-20250102150453662](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20250102150453662.png)

![image-20250102224527110](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20250102224527110.png)

tcp三次是确认身份，而TLS的四次需要向对方取一个随机数，生成会话密钥，结合1.5想想是不是需要四次：

1. 客户端（第一次握手）

   - `client hello`消息携带TLS版本号、密码套件、**随机数**请求

2. 服务端（第二次握手）

   - 确认版本号、**选择密码套件、生成随机数**

   - 包含进`Server hello`消息
   - 服务器为了证明自己身份，发送`server certificate`消息给客户端，包含**数字证书**

3. 客户端（第三次握手）

   - 客户端生成自己的随机数**pre-master**，并使用RSA公钥加密，通过**Client Key Exchange**消息发送给服务端
   - 此时客户端已经有了三个随机数（client random、server random、pre-master），服务端也即将拥有两个随机数，他们都可以生成自己的**会话密钥**
   - 客户端发送一个**change cipher spec** 告诉服务端开始使用会话密钥的方式通信
     - ！！！**在此之前都是明文，之后都是加密的密文**
   - 然后再发送一个**Encrypted Handshake Message（Finishd）**消息，包含的是之前内容的摘要（验证之前的消息有没有内篡改），并使用会话密钥加密一下(试试会话密钥能不能用)

4. 服务端（第四次握手）

   - 同样发送**change cipher spec** 和**Encrypted Handshake Message**

### RSA算法的缺陷

-------- **不支持前向保密**

客户端给服务端传递的第一个随机数client random是明文，第二个随机数pre-master是用公钥加密的，一旦服务端私钥泄露，通信内容就会被全部解密

为此使用了ECDHE密钥协商算法

## 4、 ECDHE握手解析

![image-20250102213934516](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20250102213934516.png)

上面这一步是因为：(n^m)%c = [(n%c)^m]%c 

底数G，模数P，随机数a、b

整个过程公开的是G P A B，只要模数P是一个很大的质数，想要解算出a b，现在的算力无法达到（**这就是DH算法**）

但是由于P是不变的，可以根据海量的数据试出P（**static DH算法，前向不安全**），于是双方在每次密钥交换通信时，都随机生成、临时使用一个P，**这就是DHE算法（即使破解出一次，下次就不用了，前向安全）**

但是由于每次都需要大量的乘法运算，导致性能不佳，于是产生了**ECDHE算法**，在前者的基础上使用**ECC椭圆曲线特性**，计算量更小，过程是：

- 双方事先商量好确认使用哪种椭圆曲线，和曲线上的基点G，这两个参数是公开的
- 各自生成一个随机数当作**私钥d，**得到公钥Q（Q=qG）
- 双方交换公钥，然后。。。具体怎么算的我也没看懂。。。总之就是很难被反推出来。。。TvT

### ECDHE握手过程

现在来重新理解四次握手的意义：

第一次握手：*一个消息*

- TLS版本号、**支持的密码套件**、生成随机数（公开） **client hello消息**

第二次握手：*四个消息*

- 确认版本号、**选择密码套件**、生成随机数，发送**Server Hello消息**
- 证明身份，包含证书，发送**certificate消息**
- 如果选择了ECDHE密钥协商算法，就会**选择椭圆曲线**，也就选择了**基点G**
- 生成一个随机数作为**椭圆曲线私钥（本地保存）**
- 根据G和私钥计算出**椭圆曲线公钥**（公开）（签名，防止被篡改）发送**Server Key Exchange消息**
- 发送**server hello done消息**，表示打招呼结束

第三次握手：*三个消息*

- 验证证书合法性
- 客户端生成随机数作为**椭圆曲线私钥**，生成**椭圆曲线公钥**（pre-master），发送**client key exchange消息**
- 至此双方都有了**--自己的--椭圆曲线私钥**，**--对方的--椭圆曲线公钥，椭圆曲线基点G**，双方都计算出了一个坐标值xy，x坐标双方是一样的
- 回话密钥 = **f ( client random + server random + x )**,三个随机数共同生成
- 然后发送**Change Cipher Spec消息**，【cipher 密码】，告诉服务端后面使用加密通话
- 客户端再发送**Encrypted Handshake Message消息** 【encrypted 加密】，对内容做个摘要，再对称加密一下

第四次握手：*两个消息*

重复ccs和ehm，正式开始加密通话





## 密码套件解释：

[SSL/TLS Cipher Suites-CSDN博客](https://fuhanghang.blog.csdn.net/article/details/123126052?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Ctr-3-123126052-blog-98471171.235^v43^pc_blog_bottom_relevance_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Ctr-3-123126052-blog-98471171.235^v43^pc_blog_bottom_relevance_base2&utm_relevant_index=6)

TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA1

密钥交换算法+签名算法+对称加密算法+摘要算法

TLS 通信协议

ECDHE：秘钥交换算法

ECDSA：身份验证算法

AES_128_CBC：通信时使用的对称加密算法

SHA1：信息摘要算法

**举例：**

1、TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256

[理解 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256-CSDN博客](https://blog.csdn.net/H_O_W_E/article/details/125247938)

1)浏览器与服务器协商使用 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 密码套件。
(2)密钥交换：通过 **ECDHE** 生成一个临时会话密钥。
(3)身份验证：服务器用 **RSA** 签名证明其身份。
(4)数据加密：使用 **AES-128-GCM** 加密你的输入（如用户名和密码）。
(5)完整性验证：用 SHA256 确保传输中的数据未被篡改。
结果：你安全地登录了银行网站，数据传输被保护，攻击者不能轻易窃取或篡改。

<img src="https://raw.githubusercontent.com/L1yb/PICGO/main/image-20250102163445918.png" alt="image-20250102163445918" style="zoom: 50%;" />

TLS_AES_128_GCM_SHA256 (0x1301)

这个没有显式的标出密钥交换和认证，其实在TLS1.3已经将ECDHE内嵌到加密套件中了，TLS1.3默认使用密钥交换算法（ECDHE、RSA)与加密算法(AES、GCM)

<img src="https://raw.githubusercontent.com/L1yb/PICGO/main/image-20250102163509735.png" alt="image-20250102163509735" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/L1yb/PICGO/main/image-20250102162440802.png" alt="image-20250102162440802"  />













