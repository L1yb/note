# 一、 常见问题

## 1.1 HTTP基本概念

HTTP是超文本传输协议

**超文本是什么？**

文本：字符文字、图片、视频、压缩包

超文件：是文字、图片、视频等的混合体，**最关键的是有超链接**，能从一个超文本跳转到另一个超文本

HTML就是一个常见的超文本

> **HTTP 是一个在计算机世界专门在两点之间传输超文本数据的约束和规范**

### 1.1.1 常见的状态码有哪些？

![image-20241220145645294](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241220145645294.png)

2XX表示服务器成功处理了客户端的请求

- **200 OK**：表示一切正常，如果是 非HEAD请求，服务器返回响应头有body数据
- **204 No Content**：表示一切正常，响应头没有body数据
- **206 Partial Content**：是应用于HTTP分块下载或断点续传，表示响应的body数据不是全部，而是其中一部分，也表示成功处理

3XX表示客户端请求的资源发生了变化，需要客户端用新的URL重新发送请求获取资源，**重定向**

- **301 Moved Permanently**：表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- **302 Found**：表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

​	301 和 302 都会在响应头里使用字段location，指明后续要跳转的URL，浏览器会自动重新定向新的URL

- **304 Not Modified**：不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

4XX状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。

- 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。

- 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

5XX状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 「**500 Internal Server Error**」：与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。

- **501 Not Implemented**：表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思

- **502 Bad Gateway**通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。

- **503 Service Unavailable**表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

### 1.1.2 HTTP常见字段有哪些？

1. host字段：客户端发送请求时用来指定服务器域名
2. Content-Length字段：表明本次回应的数据长度
   这是为了解决粘包问题，HTTP协议设置回车符、换行符作为header的边界，通过Content-Length作为body边界
3. Connection字段：常用于客户端请求服务器使用**HTTP长链接**机制，便于复用
4. Content-Type 字段：用于服务器回应时，告诉客户端本次数据是什么格式
5. *Content-Encoding 字段*：说明数据压缩方法，表示返回的数据使用了什么压缩格式



## 1.2 GET和POST

### 1.2.1 区别

**GET的语意是从服务器获取指定的资源**，GET请求的参数位置一般是写在URL中，URL规定只支持ASCII，所以get请求的参数只允许ASCII字符，而且浏览器对URL的长度有限制（http协议对url场地没有规定）

**POST的语意是根据请求负荷（报文body）对指定的资源作出处理**。post请求携带数据的位置是报文的body，body中的数据可以是任何类型，浏览器不会对body的大小做出限制

### 1.2.2 GET和POST方法都是安全和幂等的吗

**安全**是指请求方法不会破坏服务器上的资源

**幂等**指的是多次执行相同的操作，结果都是相同的

按照**RFC规范**定义的语意来说：

- GET方法就是安全且幂等的，因为他是只读操作，可以对GET请求的数据做缓存，这个缓存可以做在浏览器本身上，也可以做在代理上，而且浏览器中的GET请求可以保存为书签

- POST因为是新增或者提交数据，会修改服务器上的资源，所以是不安全的；且多次提交数据就会创建多个资源，因此是不幂等的，所以浏览器一般不会缓存POST请求，也不能把POST请求作为书签

但是实际中，并不一定按照RFC规范的语意来实现POST和GET，比如：

- 可以用GET方法实现新增和删除数据的请求
- 可以用POST实现查询数据的请求

因为HTTP传输的内容都是明文，所以只要抓个包就能看到，为了避免数据被窃取，就要使用HTTPS协议，这样所有HTTP的数据都会被加密传输



## 1.3 HTTP缓存技术

### 1.3.1 HTTP缓存有哪些实现方式？

对于一些具有重复性的HTTP请求，可以把这对请求-响应的数据都存在在本地，下次可以直接读取本地数据，不必通过网络获取服务器响应了

缓存有两种方式：

- 强制缓存
- 协商缓存

### 1.3.2 强制缓存

强制缓存指的是 只要浏览器判断缓存没有过期，就直接使用浏览器的本地缓存，决定是否使用缓存的主动性在浏览器

强制缓存是利用一下两个HTTP响应头部字段实现的

- Cache-Control，相对时间
- Expires：绝对时间

如果同时存在的话，**相对时间优先级高于绝对时间**

Cache-Control实现的流程是：

- 当浏览器第一次访问服务器资源时，服务器会返回这个资源的同时，在Response Header添加Cache-Control，其中设置了过期时间
- 浏览器再次访问的时候，会**先通过请求资源的时间与Cache-Control中设置的过期时间大小，计算该资源是否过期**，如果没有过期，就是用该缓存，否则就向服务器重新申请
- 服务器再次收到请求后，会更新Response Header中的Cache-Control

### 1.3.3 协商缓存

浏览器某些请求的响应码是304，服务器这是在告诉浏览器可以使用本地缓存的资源，这就是协商缓存

![image-20241220214854619](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241220214854619.png)

协商缓存基于两种头部来实现：

1. 第一种方式是**基于时间**，请求头部中的If-Modified-Since 字段与响应尾部的Last-Modified字段实现

- Last-Modified：标识这个响应资源的最后修改时间
- If-Modified-Since：**当资源过期了**，发现响应头部中具有Last-Modified声明，**则再次发送请求的时候带上Last-Modified的时间**，服务器收到请求后发现If-Modified-Since则与被请求资源的Last-Modified进行对比，如果修改时间比较新，说明被修改过，则返回最新资源（HTTP 200 OK）；如果资源无新的修改，响应HTTP 304走缓存

2. 第二种方式是基于一个**唯一标识ETag**，请求头部中的if-None-Match和响应头部的ETag

- ETag:唯一标识响应资源
- if-None-Match：**当资源过期时**，浏览器发现头部有ETag，**则再次向服务器发起请求时会将if-None-Match值设置为ETag的值**。服务器收到请求回进行对比，没有变化就返回304，变化了就返回200

相比而言：后者更能准确的判断文件是否被修改过，避免存改时间导致不可靠

> 图片中的过期从何而言？协商缓存的标准是是否被修改。这个问题在下面就被解答了，因为只有强制缓存过期了，再回请求协商缓存
>
> 那又有一个问题了，如果没过期，但是文件变动了怎么办？

如果请求中同时携带了Last-Modified和ETag，**ETag的优先级更高**，然后在看Last-Modified，理由如下：

1. 没有修改文件，最后修改时间也可能发生变化
2. 有些文件是在秒级以内修改的，If-Modified-Since等检查到的粒度就是秒级的，使用ETag可以允许客户端在一秒内多次修改
3. 有些服务器不能准确的获取文件的最后修改时间

**注意：协商缓存这两个字段都需要配合强制缓存中的Cache-Control来使用，只有在未能命中强制缓存的时候，才能发起协商缓存请求**

![image-20241220220936293](https://raw.githubusercontent.com/L1yb/PICGO/main/image-20241220220936293.png)

## 这里引入一个问题：如果强制缓存没过期，但是文件修改了，会发生什么？

显然，浏览器依然会优先读取本地缓存数据，新数据客户端无法得知

解决方法有三个：

1. 更改文件的URL，添加版本号或者哈希值，成为一个新的URL
   **这里就有新问题了，那如果每次都修改URL，完全没用到缓存，就不是缓存技术了**
   上面这个疑问明显是不得其法~
   解答：当资源修改之后，更改URL，使得URL变得像ETag一样唯一标识资源，但是变动的资源视为新资源，使用新的URL，**原本的URL访问服务器可能会404**，对此需要配套**设置重定向的映射表**
   - 使用场景：静态资源（如 JS（负责网页行为）/CSS（负责网页样式、美化）/图片）

2. 将更新时间设置的小一点，**使用短强制缓存+协商缓存**
3. **服务端推送机制**：对于高级使用场景，服务器可以在资源变动后主动告知客户端

